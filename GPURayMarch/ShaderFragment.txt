float RayMarch(vec3 ro, vec3 rd)
{
	vec3 rp = ro;
	float s = 0; //Distance travelled
	for (int Step = 0; Step<MAX_STEPS; Step++)
	{
		float d = sDist(rp); //Distance
		rp += rd*d;
		s += d;
		if (d<MIN_STEP || s > MAX_DIST)
		{
			break;
		}
	}
	return s;

}

vec3 GetNormal(vec3 p)
{
	vec3 Norm = vec3(0.0);
	float s = sDist(p);
	Norm.x = sDist(p+x_hat*delta) - s;
	Norm.y = sDist(p+y_hat*delta) - s;
	Norm.z = sDist(p+z_hat*delta) - s;
	return normalize(Norm);

}

float GetLight(vec3 p, vec3 LightPos)
{
	vec3 normal = GetNormal(p);
	vec3 p_to_l = LightPos-p;
	vec3 norm_p_to_l = normalize(p_to_l);
	
	float light_level = clamp(dot(normal,norm_p_to_l),0.0,1.0);
	//Shadows //Need 2*MinStep*Normal as otherwise will return hit everywhere
	if (RayMarch(p+2*MIN_STEP*normal,norm_p_to_l)<length(p_to_l))
	{
		//Light blocked
		light_level *= 0.1;	
	}	
	return light_level;
}

vec3 GetH(vec3 d)
{
    d = normalize(d);
    vec3 H = vec3(d.y, -d.x, 0);
    return normalize(H);
}



void main()
{
	vec3 CamDir = vec3(1.0,0.0,0.0);
	//vec3 CamPos = vec3(0.0,0.0,1.0);
	float Zoom = 1.0;
	vec3 LightPos = vec3(4.0,2.0,8.0);
	
	vec3 H = GetH(CamDir);
	vec3 V = cross(H,CamDir);
	
	
	
	vec3 ro = CamPos;
	vec3 rd = normalize(Zoom*CamDir + V*FragCoord.y + H*FragCoord.x);
	vec3 rp = ro + RayMarch(ro,rd)*rd;
	
	
	FragColor = vec4(0.0,0.0,GetLight(rp,LightPos),1.0);
}